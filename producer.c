/**
 * @file producer.c
 * @author Arun Karki
 * @date 2023-11-12
 * 
 */

#include "shared_lib.h"

// check if file size exceeds available space in buffers
void check_buffer_space(int* file_size){
    int MAX_SPACE = SHM_BUFFER_SIZE * NUM_BUFFER;
    if(*file_size > MAX_SPACE){
        perror("file size exceeds buffer(s) max size");
        exit(EXIT_FAILURE);
    }
}

// msg_get() -> returns msgqid
int message_get(){
    int msgqid = msgget(QUEUE_KEY, QUEUE_PERMISSION);

    if(msgqid == -1){
        perror("msgget failure\n");
        exit(EXIT_FAILURE);
    }
    return msgqid;
}

// msg_snd() -> -1 or 0
void message_send(struct msg_data* data, char* request){
    int msgqid = message_get();

    sprintf(data->message, "%s", request); // this is the request message being sent to the server

    data->client_pid = getpid(); // server will use this to write back

    if(msgsnd(msgqid, (void*) data, sizeof(*data), 0) == -1){
        perror("msgsnd failed\n");
        exit(EXIT_FAILURE);
    }
}

// msg_rcv() -> # bytes received or -1
key_t message_receive(struct msg_data *data){
    int msgqid = message_get();

    if(msgrcv(msgqid, (void*) data, sizeof(*data), data->msg_type, 0) == -1){
        perror("msgrcv failed\n");
        exit(EXIT_FAILURE);
    }

    int key; // response sent from server
    sscanf(data->message, "RESPONSE;%d", &key);
    return (key_t) key;
}

// request file's size from the server
size_t get_input_file_size(struct msg_data* data, char* request, char* file_name){

    data->msg_type = SERVER_MSG_TYPE; // send a type 1 for server to read
    sprintf(request, "REQUEST;%s;%s", FILE_SIZE_REQ_MSG, file_name);
    message_send(data, request);
    // file size received from server
    data->msg_type = getpid(); // receive to client that sent the request
    
    return message_receive(data);
}

// return the shared memory key generated by server
key_t get_shm_key(struct msg_data* data, char* request){

    data->msg_type = SERVER_MSG_TYPE; // send a type 1 for server to read
    sprintf(request, "REQUEST;%s", SH_MEM_REQ_MSG);
    message_send(data, request);

    // shared memory key received from server
    data->msg_type = getpid(); // receive to client that sent the request
    return message_receive(data);
}

// return the semaphore key generated by server
key_t get_sem_key(struct msg_data* data, char* request){
    data->msg_type = SERVER_MSG_TYPE; // send a type 1 for server to read
    sprintf(request, "REQUEST;%s", SEM_REQ_MSG);
    message_send(data, request);

    // semaphore key received from server
    data->msg_type = getpid(); // receive to client that sent the request
    return message_receive(data);
}

// get shared memory region
key_t get_shared_mem(key_t *shm_key){
    key_t shm_id = shmget(*shm_key, sizeof(struct shm_buffer) * NUM_BUFFER, SHM_PERMISSION);
    if (shm_id == -1){
        fprintf(stderr, "shmget failed\n");
        exit(EXIT_FAILURE);
    }
    return shm_id;
}
// attach to the shared memory region
void attach_shared_mem(key_t* shm_id, void** shm_ptr){
    *shm_ptr = shmat(*shm_id, (void *)0, 0);
    if (*shm_ptr == (void *)-1){
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }
}

/* SEMAPHORE Functions */

// initialize the semaphores
static int set_semvalue(key_t* sem_id){
    /*
    0: Empty
    1: Full
    2: Mutex
    3: Destroy
    */
    union semun sem_union;

    // set up sem Empty
    sem_union.val = NUM_BUFFER;
    if (semctl(*sem_id, 0, SETVAL, sem_union) == -1)
        return (0);

    // set up sem Full
    sem_union.val = 0;
    if (semctl(*sem_id, 1, SETVAL, sem_union) == -1)
        return (0);

    // set up sem Mutex
    sem_union.val = 1;
    if (semctl(*sem_id, 2, SETVAL, sem_union) == -1)
        return (0);

    // set up sem Destroy
    sem_union.val = 0;
    if (semctl(*sem_id, 3, SETVAL, sem_union) == -1)
        return (0);

    return (1);
}
// delete
static void del_semvalue(key_t* sem_id){
    union semun sem_union;
    if (semctl(*sem_id, 0, IPC_RMID, sem_union) == -1)
        fprintf(stderr, "Failed to delete semaphore\n");
}
// wait()
static int semaphore_p(key_t* sem_id, int sem_num){
    struct sembuf sem_b;
    sem_b.sem_num = sem_num;
    sem_b.sem_op = -1; /* P() */
    sem_b.sem_flg = SEM_UNDO;
    if (semop(*sem_id, &sem_b, 1) == -1){
        fprintf(stderr, "semaphore_p failed\n");
        return (0);
    }
    return (1);
}
// signal()
static int semaphore_v(key_t* sem_id, int sem_num){
    struct sembuf sem_b;
    sem_b.sem_num = sem_num;
    sem_b.sem_op = 1; /* V() */
    sem_b.sem_flg = SEM_UNDO;
    if (semop(*sem_id, &sem_b, 1) == -1){
        fprintf(stderr, "semaphore_v failed\n");
        return (0);
    }
    return (1);
}


// maybe use command line arguments for file name -> good idea

int main(int argc, char *argv[]){

    printf("\n---------| PRODUCER |---------\n");

    //
    char* input_file_name = "input.txt";
    int input_file;   
    int input_file_size;

    int msgqid; // queue message id
    struct msg_data data; // queue data struct
    char request; // what type of request am i making, ex. 'sh_key'

    key_t shm_key, sem_key; // shared memory and semaphore key generated by server
    key_t shm_id, sem_id; // shared memory region and semaphore id

    // the shared memory buffer pointer; attach this
    struct shm_buffer* shared_memory;
    void *shm_ptr = (void *) 0; // point to the shared region

    // get message queue
    msgqid = message_get(); // get message queue id

    // request file size from server before reading
    input_file_size = get_input_file_size(&data, &request,  input_file_name);
    check_buffer_space(&input_file_size);

    printf("input file (%d bytes): %s\n", input_file_size, input_file_name);

    /* REQUEST SHARED MEMORY KEY */
    shm_key = get_shm_key(&data, &request);
    shm_id = get_shared_mem(&shm_key); //create or get shared memory
    attach_shared_mem(&shm_id, &shm_ptr); // attach to ptr
    shared_memory = (struct shm_buffer *) shm_ptr; // assign to buffer

    printf("\nShared Memory Key: %d\n", shm_key);
    printf("Shared Memory ID: %d\n", shm_id);
    printf("Shared Memory Address: %p\n", shm_ptr);

    /* REQUEST SEMAPHORE KEY */
    sem_key = get_sem_key(&data, &request);
    sem_id = semget(sem_key, NUM_SEMAPHORE, SEM_PERMISSION);
    set_semvalue(&sem_id);

    printf("\nSemphores successfully initialized...\n");
    printf("Semaphore Key: %d\n", sem_key);
    printf("Semaphore ID: %d\n\n", sem_id);

    // read from input file and write to buffer
    input_file = open(input_file_name, O_RDONLY);

    if(input_file == -1){
        perror("error opening input file");
        exit(EXIT_FAILURE);
    }


    /* READ from input file and put into buffer(s) */
    // no need to loop thru all, calculate how many buffers are needed by (file size/size of each buffer) and round up

    int totalBytes = 0;
    for(int i = 0; i < (int) ceil(((double) input_file_size/SHM_BUFFER_SIZE)); i++){

        struct shm_buffer* curr_buff = &shared_memory[i]; // current buffer
        int bytesRead;

        // wait()
        semaphore_p(&sem_id, 0); // wait on Empty (E)
        semaphore_p(&sem_id, 2); // wait on Mutex (S)

        printf("Reading from %s and writing to Buffer[%d]...\n", input_file_name, i);
        
        // while buffer not full and im reading bytes from file:
        while(curr_buff->count < SHM_BUFFER_SIZE && (bytesRead = read(input_file, curr_buff->message, sizeof(curr_buff->message))) > 0){
            curr_buff->count += bytesRead; // # of bytes written in the buffer
        }

        // signal()
        semaphore_v(&sem_id, 2); // signal on Mutex (S)
        semaphore_v(&sem_id, 1); // signal on Full (N)

        curr_buff->sequence_number = totalBytes;
        totalBytes += curr_buff->count;
    }

    printf("\nFinished writing to buffers\n");
    printf("Transmitted: %d bytes in total.\n$$$$", totalBytes);
    semaphore_p(&sem_id, 3); // wait for consumer to say go clean up

    // clean up process
    del_semvalue(&sem_id);
    close(input_file); // close the output file
    shmctl(shm_id, IPC_RMID, NULL); // dellallocate shared memory region
       
    return 0;
}